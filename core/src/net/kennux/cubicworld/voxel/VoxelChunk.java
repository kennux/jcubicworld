package net.kennux.cubicworld.voxel;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map.Entry;

import net.kennux.cubicworld.CubicWorld;
import net.kennux.cubicworld.CubicWorldConfiguration;
import net.kennux.cubicworld.inventory.IInventory;
import net.kennux.cubicworld.inventory.IInventoryUpdateHandler;
import net.kennux.cubicworld.math.Vector3i;
import net.kennux.cubicworld.networking.packet.ClientChunkRequest;
import net.kennux.cubicworld.networking.packet.inventory.ServerBlockInventoryUpdate;
import net.kennux.cubicworld.voxel.ChunkMeshBuilder.ChunkMeshBuilderResult;
import net.kennux.cubicworld.voxel.handlers.IVoxelTileEntityHandler;
import net.kennux.cubicworld.voxel.lighting.ALightingSystem;
import net.kennux.cubicworld.voxel.lighting.BasicLightingSystem;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Mesh;
import com.badlogic.gdx.graphics.VertexAttribute;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.Quaternion;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.math.collision.BoundingBox;

/**
 * Voxel chunk implementation.
 * 
 * @author KennuX
 *
 */
public class VoxelChunk
{

	/**
	 * <pre>
	 * Rotation face mappings Indices:
	 * 0 - LEFT
	 * 1 - RIGHT
	 * 2 - TOP
	 * 3 - BOTTOM
	 * 4 - BACK
	 * 5 - FRONT
	 * 
	 * Sides mapped from initial rotation.
	 * </pre>
	 */
	public static final VoxelFace[][] ROTATION_MAPPINGS = new VoxelFace[][] {
			// Facing front
			new VoxelFace[] { VoxelFace.LEFT, VoxelFace.RIGHT, VoxelFace.TOP, VoxelFace.BOTTOM, VoxelFace.BACK, VoxelFace.FRONT },
			// Facing right
			new VoxelFace[] { VoxelFace.FRONT, VoxelFace.BACK, VoxelFace.TOP, VoxelFace.BOTTOM, VoxelFace.LEFT, VoxelFace.RIGHT },
			// Facing back
			new VoxelFace[] { VoxelFace.RIGHT, VoxelFace.LEFT, VoxelFace.TOP, VoxelFace.BOTTOM, VoxelFace.FRONT, VoxelFace.BACK },
			// Facing left
			new VoxelFace[] { VoxelFace.BACK, VoxelFace.FRONT, VoxelFace.TOP, VoxelFace.BOTTOM, VoxelFace.RIGHT, VoxelFace.LEFT } };

	/**
	 * <pre>
	 * Rotation quaternion mappings.
	 * 
	 * This array contains quaternions for all rotation ids.
	 * </pre>
	 */
	public static final Quaternion[] ROTATION_MAPPINGS_QUATERNION = new Quaternion[] { new Quaternion().setEulerAngles(0, 0, 0), new Quaternion().setEulerAngles(90, 0, 0), new Quaternion().setEulerAngles(180, 0, 0), new Quaternion().setEulerAngles(270, 0, 0) };

	/**
	 * <pre>
	 * The normal vectors for voxelfaces.
	 * Example usage:
	 * 
	 * VoxelFace f = VoxelFace.LEFT;
	 * Vector3 normal = FACE_NORMALS[f.getValue()];
	 * 
	 * All vectors are 1 unit long!.
	 * </pre>
	 */
	public static final Vector3[] FACE_NORMALS = new Vector3[] { new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), };
	/**
	 * Rotation quaternion mappings.
	 * This quaternions will get used to define a voxel model's rendering rotation based on the rotation byte.
	 * 
	 * They get calculated in the constructor.
	 */
	public static Quaternion[] rotationTransformMappings;

	// END OF STATIC DATA

	/**
	 * The current voxel mesh used for rendering.
	 */
	private Mesh voxelMesh;

	/**
	 * Gets used to synchronize voxel data changes.
	 */
	private Object voxelDataLockObject = new Object();

	/**
	 * If this flag is set to true the voxel mesh got marked as dirty, which
	 * means it needs to get re-generated.
	 */
	private boolean voxelMeshDirty;

	/**
	 * If this flag is set to true the new mesh data gots generated by the
	 * update thread.
	 */
	private boolean newMeshDataReady;

	/**
	 * The voxel mesh's bounding box.
	 */
	private BoundingBox boundingBox;

	/**
	 * The voxel data (voxeltype id's, -1 for no block here). You must lock
	 * voxelDataLockObject when you are writing to this field. After direct
	 * writing to this you must call setDirty().
	 */
	private volatile VoxelData[][][] voxelData;

	/**
	 * The chunk x-position.
	 */
	private int chunkX;

	/**
	 * The chunk y-position.
	 */
	private int chunkY;

	/**
	 * The chunk z-position.
	 */
	private int chunkZ;

	/**
	 * Gets set to true after the world generation is done.
	 */
	private boolean generationDone = false;

	/**
	 * Gets set to true if a save of this chunk to the voxel world file is
	 * needed.
	 * Will get handled in update().
	 */
	private boolean saveDirty = false;

	/**
	 * The voxel world master instance.
	 */
	public VoxelWorld master;

	/**
	 * The visible tile entity positions.
	 * Will get set in the createNewMesh() function.
	 */
	private ArrayList<Vector3i> visibleTileEntities = new ArrayList<Vector3i>();

	/**
	 * The voxel update handlers list.
	 */
	private HashMap<Vector3i, IVoxelTileEntityHandler> tileEntityHandlers = new HashMap<Vector3i, IVoxelTileEntityHandler>();

	/**
	 * The voxel update handlers list copy instance.
	 * The copy of this instance will get used for acutally firing the tile entity events.
	 * 
	 * @see VoxelChunk#update()
	 */
	private HashMap<Vector3i, IVoxelTileEntityHandler> tileEntityHandlersCopyInstance = new HashMap<Vector3i, IVoxelTileEntityHandler>();

	private Object generationLockObject = new Object();

	/**
	 * The absolute chunk position vector.
	 */
	private Vector3i absoluteChunkPosition;

	/**
	 * The mesh pool fifo stack.
	 */
	private static LinkedList<Mesh> meshPool = new LinkedList<Mesh>();

	/**
	 * The last call id when update() was called.
	 * Used to limit chunk updates per frame for lag reduction.
	 */
	private static long lastUpdateCallId = -1;

	/**
	 * Contains the number of generateMesh() calls this frame.
	 */
	private static int generationsProcessedThisFrame = -1;

	/**
	 * The last frame id when render() was called.
	 * Used to limit chunk updates per frame for lag reduction.
	 */
	private static long lastRenderFrameId = -1;

	/**
	 * Contains the number of generateMesh() calls this frame.
	 */
	private static int creationsProcessedThisFrame = -1;

	/**
	 * The new chunk mesh generation result data.
	 */
	private ChunkMeshBuilderResult newMeshData;

	/**
	 * The lighting system used by this chunk.
	 */
	private ALightingSystem lightingSystem;

	/**
	 * Creates a new mesh for the mesh pool if there is no free one.
	 * 
	 * @return
	 */
	private static Mesh newMesh()
	{
		return new Mesh(Mesh.VertexDataType.VertexBufferObject, false, 16368, 16368, new VertexAttribute(Usage.Position, 3, "v_Position"), new VertexAttribute(Usage.TextureCoordinates, 2, "v_Uv"), /* new VertexAttribute(Usage.Normal, 3, "v_Normal"), */new VertexAttribute(Usage.ColorUnpacked, 1, "v_Light"));
	}

	public VoxelChunk(int chunkX, int chunkY, int chunkZ, VoxelWorld master)
	{
		// Init lighting system
		this.lightingSystem = new BasicLightingSystem();

		this.voxelData = null;

		// Init rotation mappings
		rotationTransformMappings = new Quaternion[] {
				// Facing front
				new Quaternion(0, 0, 0, 0),
				// Facing right
				new Quaternion(0, 0, 0, 0).setEulerAngles(90, 0, 0),
				// Facing back
				new Quaternion(0, 0, 0, 0).setEulerAngles(180, 0, 0),
				// Facing left
				new Quaternion(0, 0, 0, 0).setEulerAngles(270, 0, 0) };

		// Set chunkspae position
		this.chunkX = chunkX;
		this.chunkY = chunkY;
		this.chunkZ = chunkZ;

		// Set absolute chunk position
		this.absoluteChunkPosition = new Vector3i(this.chunkX * VoxelWorld.chunkWidth, this.chunkY * VoxelWorld.chunkHeight, this.chunkZ * VoxelWorld.chunkDepth);

		this.master = master;
	}

	/**
	 * Sets this chunk to dirty which will regenerate the mesh data.
	 * ONLY call this if you loaded the chunk data from the world file.
	 */
	private void chunkDataWasLoaded()
	{
		this.lightingSystem.resetLighting();
		this.voxelMeshDirty = true;
		this.saveDirty = false;
	}

	/**
	 * Causes this chunk to regenerate it's mesh.
	 * Will only recalculate lighting and the mesh.
	 * This will also cause the adjacent chunks to regenerate their meshes.
	 */
	public void regenerateLightingAndMesh()
	{
		this.lightingSystem.resetLighting();
		this.voxelMeshDirty = true;
		this.regenerateAdjacentMeshes();
	}

	/**
	 * Causes this chunk to regenerate it's mesh.
	 */
	public void regenerateMesh()
	{
		this.voxelMeshDirty = true;
	}

	/**
	 * Regenerates the adjacent meshes.
	 * Only the meshes! no lighting calculation will be performed!
	 */
	private void regenerateAdjacentMeshes()
	{
		VoxelChunk[] chunks = new VoxelChunk[] { this.master.getChunk(chunkX + 1, chunkY, chunkZ, false), this.master.getChunk(chunkX - 1, chunkY, chunkZ, false), this.master.getChunk(chunkX, chunkY + 1, chunkZ, false), this.master.getChunk(chunkX, chunkY - 1, chunkZ, false), this.master.getChunk(chunkX, chunkY, chunkZ + 1, false), this.master.getChunk(chunkX, chunkY, chunkZ - 1, false), };

		for (VoxelChunk vc : chunks)
		{
			if (vc != null)
				vc.regenerateMesh();
		}
	}

	/**
	 * Sets this chunk to dirty which will regenerate the mesh data. You have to
	 * call this function after direct writing to voxelData.
	 */
	private void chunkDataWasModified()
	{
		this.lightingSystem.resetLighting();
		this.voxelMeshDirty = true;
		this.saveDirty = true;
	}

	/**
	 * Creates the new mesh from newVertices, newUvs, newColors and newIndices
	 * lists.
	 */
	private void createNewMesh()
	{
		synchronized (this.generationLockObject)
		{
			// This should actually never happen if no one fucked it up
			// Let's double check to prevent a full crash
			if (this.newMeshData == null)
				return;

			// Get data
			float[] newVertices = this.newMeshData.getVertices();
			short[] newIndices = this.newMeshData.getIndices();
			ArrayList<Vector3i> newVisibleTileEntities = this.newMeshData.getVisibleTileEntities();
			BoundingBox newBoundingBox = this.newMeshData.getBoundingBox();

			// Mesh empty?
			if (newVertices.length == 0)
			{
				this.voxelMesh = null;
			}
			else
			{
				// Construct new mesh
				if (this.voxelMesh == null)
				{
					this.voxelMesh = meshPool.poll();

					if (this.voxelMesh == null)
					{
						this.voxelMesh = newMesh();
					}
				}

				// Set the vertices
				this.voxelMesh.setVertices(newVertices);
				this.voxelMesh.setIndices(newIndices);

				// Set the visible tile entities
				this.visibleTileEntities = newVisibleTileEntities;

				// Calculate bounding box
				try
				{
					// DISABLED DUE TO HIGH PERFORMANCE COST
					// INSTEAD STATIC BOUNDING BOXES WILL GET USED GENERATED IN generateMesh()
					// this.boundingBox = newMesh.calculateBoundingBox();
					this.boundingBox = newBoundingBox;
				}
				catch (Exception e)
				{
					// Happens if there are no vertices in this mesh, so just ignore this error.
				}
			}

			this.newMeshDataReady = false;
			this.voxelMeshDirty = false;

			// Free old data
			this.newMeshData = null;
		}
	}

	/**
	 * This call is not thread-safe, only call this on an object which wont get used anymore.
	 * 
	 * This will not get called by the garbage collector as this class does not implement the disposable interface.
	 * It is only used to add the current mesh to the mesh pool.
	 */
	public void dispose()
	{
		meshPool.add(this.voxelMesh);
	}

	/**
	 * Generates the voxel mesh based on the current chunk's voxel data.
	 */
	private void generateMesh()
	{
		synchronized (this.generationLockObject)
		{
			if (!this.lightingSystem.isReady() || this.voxelData == null)
				return;

			this.newMeshData = ChunkMeshBuilder.buildMeshData(this);

			this.newMeshDataReady = true;
		}
	}

	/**
	 * Calculates an absolute position from the given local blockspace position.
	 * 
	 * @param x
	 * @param y
	 * @param z
	 * @param vector
	 * @return
	 */
	public Vector3i getAbsoluteVoxelPosition(int x, int y, int z, Vector3i vector)
	{
		vector.x = x + this.absoluteChunkPosition.x;
		vector.y = y + this.absoluteChunkPosition.y;
		vector.z = z + this.absoluteChunkPosition.z;
		return vector;
	}

	/**
	 * Calculates an absolute position from the given local blockspace position.
	 * 
	 * @see VoxelChunk#getAbsoluteVoxelPosition(int, int, int, Vector3i)
	 * @param x
	 * @param y
	 * @param z
	 * @return
	 */
	public Vector3i getAbsoluteVoxelPosition(int x, int y, int z)
	{
		return this.getAbsoluteVoxelPosition(x, y, z, new Vector3i(0, 0, 0));
	}

	/**
	 * Returns the bounding box for a voxel given in local voxelspace.
	 * If there is no voxel at this position, null will be returned.
	 * If the voxel is a non-collidable (like vegetation), also null is
	 * returned.
	 * 
	 * @param x
	 * @param y
	 * @param z
	 * @return
	 */
	public BoundingBox getBoundingBox(int x, int y, int z)
	{
		// Bounds check
		if (this.voxelData != null && x >= 0 && y >= 0 && z >= 0 && x < VoxelWorld.chunkWidth && y < VoxelWorld.chunkHeight && z < VoxelWorld.chunkDepth && this.hasVoxel(x, y, z))
		{
			return new BoundingBox(new Vector3(x, y, z), new Vector3(x + 1, y + 1, z + 1));
		}

		// Not found!
		return null;
	}

	/**
	 * Returns the global light level of the block at the given position.
	 * Returns -1 if there is no voxel in the given position or if an error
	 * happend.
	 * 
	 * @param x
	 * @param y
	 * @param z
	 * @return
	 */
	public byte getGlobalLightLevel(int x, int y, int z)
	{
		// Bounds check
		if (this.voxelData != null && x >= 0 && y >= 0 && z >= 0 && x < VoxelWorld.chunkWidth && y < VoxelWorld.chunkHeight && z < VoxelWorld.chunkDepth)
		{
			synchronized (this.voxelDataLockObject)
			{
				if (this.voxelData[x][y][z] != null)
					return this.voxelData[x][y][z].getBlockLightLevel();
			}
		}

		// Not found!
		return -1;
	}

	/**
	 * Gets the voxel data at the given x|y|z position.
	 * Returns null in the case of an error.
	 * 
	 * @param x
	 * @param y
	 * @param z
	 * @param voxel
	 * @return
	 */
	public VoxelData getVoxel(int x, int y, int z)
	{
		// Bounds check
		if (this.voxelData != null && x >= 0 && y >= 0 && z >= 0 && x < VoxelWorld.chunkWidth && y < VoxelWorld.chunkHeight && z < VoxelWorld.chunkDepth)
		{
			synchronized (this.voxelDataLockObject)
			{
				return this.voxelData[x][y][z];
			}
		}

		// Not found!
		return null;
	}

	/**
	 * Returns a copy of the voxel data array.
	 * Only the array object is a copy, the voxeldata contents of the array are
	 * references.
	 * 
	 * @return
	 */
	public VoxelData[][][] getVoxelData()
	{
		synchronized (this.voxelDataLockObject)
		{
			if (this.voxelData == null)
				return null;

			return this.voxelData.clone();
		}
	}

	/**
	 * Checks if the the voxel data at the given x|y|z position is not null or
	 * type id -1. Returns false in the case of an error.
	 * 
	 * @param x
	 * @param y
	 * @param z
	 * @param voxel
	 * @return
	 */
	public boolean hasVoxel(int x, int y, int z)
	{
		// Bounds check
		if (this.voxelData != null && x >= 0 && y >= 0 && z >= 0 && x < VoxelWorld.chunkWidth && y < VoxelWorld.chunkHeight && z < VoxelWorld.chunkDepth)
		{
			synchronized (this.voxelDataLockObject)
			{
				return this.voxelData[x][y][z] != null && this.voxelData[x][y][z].voxelType != null;
			}
		}

		// Not found!
		return false;
	}

	/**
	 * Returns true if the world generator already generated this chunk.
	 * 
	 * @return
	 */
	public boolean isGenerationDone()
	{
		return generationDone;
	}

	/**
	 * Returns true if this voxel chunk is ready for rendering (this means, lighting is done and mesh is generated).
	 * 
	 * @return
	 */
	public boolean isReadyForRendering()
	{
		return this.isInitializedAndLightingReady() && !this.voxelMeshDirty && !this.newMeshDataReady;
	}

	/**
	 * Chunk gets initialized after data got set by the generator or it was
	 * loaded from hdd
	 * 
	 * @return
	 */
	public boolean isInitialized()
	{
		return this.voxelData != null && this.isGenerationDone();
	}

	/**
	 * @see ALightingSystem#isPassDone(Class)
	 * @param lightingPassClass
	 * @return
	 */
	public boolean isLightingPassDone(Class lightingPassClass)
	{
		return this.lightingSystem.isPassDone(lightingPassClass);
	}

	/**
	 * Returns true if this chunk is initialized and it's lighting is not dirty.
	 * 
	 * @return
	 */
	public boolean isInitializedAndLightingReady()
	{
		return this.isInitialized() && this.lightingSystem.isReady();
	}

	/**
	 * Loads the voxel data from the voxel chunk file.
	 */
	public void loadVoxelData()
	{
		if (this.master.hasWorldFile() && this.master.getWorldFile().hasChunk(chunkX, chunkY, chunkZ))
		{
			synchronized (this.voxelDataLockObject)
			{
				// Read
				this.voxelData = this.master.getWorldFile().readChunk(chunkX, chunkY, chunkZ);
				this.setInventoryUpdateHandlerAll();
				this.chunkDataWasLoaded();
				this.setGenerationDone(true);
				this.setTileEntityHandlerAll();
			}
		}
	}

	/**
	 * <pre>
	 * Renders this chunk. Will do nothing if the current voxel mesh is not
	 * available yet.
	 * 
	 * Otherwise it will just call the render() method of the chunk mesh object.
	 * 
	 * This method is <b>NOT</b> thread-safe.
	 * </pre>
	 */
	public void render(Camera cam, ShaderProgram shader)
	{
		CubicWorld.getClient().profiler.startProfiling("MeshCreation" + this.chunkX + "|" + this.chunkY + "|" + this.chunkZ, "");
		boolean frameMismatch = lastRenderFrameId != Gdx.graphics.getFrameId();

		if (this.voxelMeshDirty && this.newMeshDataReady && (CubicWorldConfiguration.meshCreationsPerFrameLimit == -1 || frameMismatch || creationsProcessedThisFrame <= CubicWorldConfiguration.meshCreationsPerFrameLimit))
		{
			// If the frame ids mismatch
			if (frameMismatch)
			{
				// Update frame id and reset counter
				lastRenderFrameId = Gdx.graphics.getFrameId();
				creationsProcessedThisFrame = 0;
			}

			this.createNewMesh();
			creationsProcessedThisFrame++;
		}
		CubicWorld.getClient().profiler.stopProfiling("MeshCreation" + this.chunkX + "|" + this.chunkY + "|" + this.chunkZ);

		CubicWorld.getClient().profiler.startProfiling("MeshRendering" + this.chunkX + "|" + this.chunkY + "|" + this.chunkZ, "");
		if (this.voxelMesh != null && this.boundingBox != null && cam.frustum.boundsInFrustum(this.boundingBox))
		{
			// Render chunk mesh
			this.voxelMesh.render(shader, GL20.GL_TRIANGLES);
		}
		CubicWorld.getClient().profiler.stopProfiling("MeshRendering" + this.chunkX + "|" + this.chunkY + "|" + this.chunkZ);
	}

	/**
	 * The tile entity rendering pass.
	 */
	public void renderTileEntities(Camera cam)
	{
		if (this.voxelMesh != null && this.boundingBox != null && cam.frustum.boundsInFrustum(this.boundingBox))
		{
			// Render tile entities
			CubicWorld.getClient().profiler.startProfiling("TileEntityRendering" + this.chunkX + "|" + this.chunkY + "|" + this.chunkZ, "");
			for (Vector3i pos : this.visibleTileEntities)
			{
				// Get the tile entity handler
				IVoxelTileEntityHandler tileEntityHandler = this.tileEntityHandlers.get(pos);

				// Check if the tile entity handler is not null for error prevention
				if (tileEntityHandler != null)
				{
					// Handle the render call
					tileEntityHandler.handleRender(cam, this.getVoxel(pos.x, pos.y, pos.z), pos.x + (this.chunkX * VoxelWorld.chunkWidth), pos.y + (this.chunkY * VoxelWorld.chunkHeight), pos.z + (this.chunkZ * VoxelWorld.chunkDepth));
				}
			}
			CubicWorld.getClient().profiler.stopProfiling("TileEntityRendering" + this.chunkX + "|" + this.chunkY + "|" + this.chunkZ);
		}
	}

	/**
	 * Call this with true as parameter after the generation of the chunk is
	 * done.
	 * 
	 * @param generationDone
	 */
	public void setGenerationDone(boolean generationDone)
	{
		this.generationDone = generationDone;
	}

	/**
	 * Helper function for setting the inventory update handler.
	 * 
	 * @param positionX
	 * @param positionY
	 * @param positionZ
	 * @param inventory
	 */
	private void setInventoryUpdateHandler(int positionX, int positionY, int positionZ, VoxelData inventoryVoxel)
	{
		if (this.master.isServer() && inventoryVoxel != null && inventoryVoxel.blockInventory != null)
		{
			// Declare final positions
			final int posX = positionX;
			final int posY = positionY;
			final int posZ = positionZ;
			final VoxelChunk chunkInstance = this;

			inventoryVoxel.blockInventory.setUpdateHandler(new IInventoryUpdateHandler()
			{
				@Override
				public void inventoryGotUpdated(IInventory inventory)
				{
					ServerBlockInventoryUpdate updatePacket = new ServerBlockInventoryUpdate();
					updatePacket.inventory = inventory;
					updatePacket.voxelPositionX = posX;
					updatePacket.voxelPositionY = posY;
					updatePacket.voxelPositionZ = posZ;
					updatePacket.setCullPosition(new Vector3(posX, posY, posZ));

					CubicWorld.getServer().sendPacket(updatePacket);
					chunkInstance.chunkDataWasModified();
				}
			});
		}
	}

	/**
	 * This function will call the setInventoryUpdateHandler for every voxel data which has a inventory attached.
	 * 
	 * @see VoxelChunk#setInventoryUpdateHandler(int, int, int, VoxelData)
	 */
	private void setInventoryUpdateHandlerAll()
	{
		if (!this.master.isServer())
			return;

		for (int x = 0; x < VoxelWorld.chunkWidth; x++)
			for (int y = 0; y < VoxelWorld.chunkHeight; y++)
				for (int z = 0; z < VoxelWorld.chunkDepth; z++)
					if (this.voxelData[x][y][z] != null && this.voxelData[x][y][z].blockInventory != null)
					{
						Vector3i absolutePos = this.getAbsoluteVoxelPosition(x, y, z);
						this.setInventoryUpdateHandler(absolutePos.x, absolutePos.y, absolutePos.z, this.voxelData[x][y][z]);
					}
	}

	/**
	 * Sets the voxel data at the given x|y|z position.
	 * Pass in null or just new VoxelData() as voxel for setting air.
	 * You can and must use this function also if you update a voxel data object to send out a world update on the server.
	 * Don't use this for changes on the client as the client has to send packets for updating the voxel world.
	 * 
	 * @param x
	 * @param y
	 * @param z
	 * @param voxel
	 */
	public void setVoxel(int x, int y, int z, VoxelData voxel)
	{
		synchronized (this.voxelDataLockObject)
		{
			if (this.voxelData == null)
				return;

			// if voxel is null, create air voxel
			if (voxel == null)
				voxel = new VoxelData();

			// Remove update handler if existing
			Vector3i voxelPos = new Vector3i(x, y, z);
			this.tileEntityHandlers.remove(voxelPos);

			this.voxelData[x][y][z] = voxel;

			// Inventory
			if (voxel != null && voxel.blockInventory != null)
			{
				Vector3i absolutePos = this.getAbsoluteVoxelPosition(x, y, z);
				this.setInventoryUpdateHandler(absolutePos.x, absolutePos.y, absolutePos.z, voxel);
			}

			this.chunkDataWasModified();

			// notify about update
			if (this.master.getVoxelDataUpdateHandler() != null)
			{
				Vector3i absolutePos = this.getAbsoluteVoxelPosition(x, y, z);
				this.master.getVoxelDataUpdateHandler().handleVoxelDataUpdate(absolutePos.x, absolutePos.y, absolutePos.z, voxel);
			}

			// Update voxel handlers map
			if (voxel != null && voxel.voxelType != null)
			{
				if (voxel.voxelType.isTileEntity() && voxel.tileEntity != null)
				{
					this.tileEntityHandlers.put(voxelPos, voxel.tileEntity);
				}
			}
		}
	}

	/**
	 * Sets the voxel data array.
	 * 
	 * @param voxelData
	 */
	public void setVoxelData(VoxelData[][][] voxelData)
	{
		synchronized (this.voxelDataLockObject)
		{
			// Iterate through all voxel datas and set null voxels to air voxels
			for (int x = 0; x < voxelData.length; x++)
				for (int y = 0; y < voxelData[x].length; y++)
					for (int z = 0; z < voxelData[x][y].length; z++)
						if (voxelData[x][y][z] == null)
							voxelData[x][y][z] = new VoxelData();

			this.voxelData = voxelData;
			this.setInventoryUpdateHandlerAll();
			this.chunkDataWasModified();
			this.setGenerationDone(true);
			this.setTileEntityHandlerAll();
		}
	}

	/**
	 * Iterates through every voxel data in this instance and collects all tile entity handlers.
	 */
	private void setTileEntityHandlerAll()
	{
		synchronized (this.voxelDataLockObject)
		{
			this.tileEntityHandlers.clear();

			// Iterate through all voxel data instances
			for (int x = 0; x < this.voxelData.length; x++)
				for (int y = 0; y < this.voxelData[x].length; y++)
					for (int z = 0; z < this.voxelData[x][y].length; z++)
						// Check if the voxel at the given position is not null, not air and a tile entity
						if (this.voxelData[x][y][z] != null && this.voxelData[x][y][z].voxelType != null && this.voxelData[x][y][z].voxelType.isTileEntity())
							// Add to tile entity handlers
							this.tileEntityHandlers.put(new Vector3i(x, y, z), this.voxelData[x][y][z].tileEntity);

		}
	}

	/**
	 * Simulates the current chunk. Currently this doesnt do anything but it
	 * will be called once per tick (ticksPerSecond = fps on client, target
	 * ticks on server are 20).
	 */
	public void simulate()
	{
		// TODO Fluid Simulation
	}

	/**
	 * <pre>
	 * Updates this voxel chunk instance.
	 * Does the following:
	 * 
	 * - Checks if save to hdd needed
	 * -> If yes, it will save to hdd
	 * - Checks if the lighting is dirty and needs a regeneration
	 * -> If yes, it regenerates it.
	 * - Checks if the mesh is dirty
	 * -> If yes, it regenerates it.
	 * </pre>
	 */
	public void update()
	{
		// Save needed?
		if (this.saveDirty && this.master.hasWorldFile() && this.isInitialized())
		{
			synchronized (this.voxelDataLockObject)
			{
				// Save chunk
				this.master.getWorldFile().writeChunk(this.chunkX, this.chunkY, this.chunkZ, this.voxelData);
				this.saveDirty = false;
			}
		}

		// Lighting calculation
		synchronized (this.voxelDataLockObject)
		{
			this.lightingSystem.update(this);
		}

		synchronized (this.voxelDataLockObject)
		{
			this.tileEntityHandlersCopyInstance.clear();
			for (Entry<Vector3i, IVoxelTileEntityHandler> entry : this.tileEntityHandlers.entrySet())
			{
				this.tileEntityHandlersCopyInstance.put(entry.getKey(), entry.getValue());
			}

			// Exec tile entity updates
			for (Entry<Vector3i, IVoxelTileEntityHandler> entry : this.tileEntityHandlersCopyInstance.entrySet())
			{
				int x = (int) entry.getKey().x;
				int y = (int) entry.getKey().y;
				int z = (int) entry.getKey().z;

				Vector3i absolutePosition = this.getAbsoluteVoxelPosition((int) entry.getKey().x, (int) entry.getKey().y, (int) entry.getKey().z);

				VoxelData voxelData = this.getVoxel(x, y, z);

				entry.getValue().handleUpdate(voxelData, absolutePosition.x, absolutePosition.y, absolutePosition.z, this.master.isServer());
			}
		}

		boolean frameMismatch = (lastUpdateCallId != this.master.updateCallId);

		if (!ClientChunkRequest.areRequestsPending() && this.lightingSystem.isReady() && this.voxelMeshDirty && this.generationDone && !this.master.isServer() &&
		// Check all neighbours if lighting is ready
				this.master.chunkLightingReady(this.chunkX + 1, this.chunkY, this.chunkZ) && this.master.chunkLightingReady(this.chunkX - 1, this.chunkY, this.chunkZ) && this.master.chunkLightingReady(this.chunkX, this.chunkY + 1, this.chunkZ) && this.master.chunkLightingReady(this.chunkX, this.chunkY - 1, this.chunkZ) && this.master.chunkLightingReady(this.chunkX, this.chunkY, this.chunkZ + 1) && this.master.chunkLightingReady(this.chunkX, this.chunkY, this.chunkZ - 1) && (CubicWorldConfiguration.meshGenerationsPerFrameLimit == -1 || frameMismatch || generationsProcessedThisFrame <= CubicWorldConfiguration.meshGenerationsPerFrameLimit))
		{
			// If the frame ids mismatch
			if (frameMismatch)
			{
				// Update frame id and reset counter
				lastUpdateCallId = this.master.updateCallId;
				generationsProcessedThisFrame = 0;
			}

			this.generateMesh();
			generationsProcessedThisFrame++;
		}
	}

	public int getChunkX()
	{
		return this.chunkX;
	}

	public int getChunkY()
	{
		return this.chunkY;
	}

	public int getChunkZ()
	{
		return this.chunkZ;
	}
}
